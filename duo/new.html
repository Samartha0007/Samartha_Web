const container = document.querySelector(".container");  
const chatsContainer = document.querySelector(".chats-container");  
const promptForm = document.querySelector(".prompt-form");  
const promptInput = promptForm.querySelector(".prompt-input");  
const fileInput = promptForm.querySelector("#file-input");  
const fileUploadWrapper = promptForm.querySelector(".file-upload-wrapper");  
  
const API_KEY = "AIzaSyAL-uu_Ow_cWsW2FvTAd5071hBfB8StOas";  
const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${API_KEY}`;  
  
let controller, typingInterval;  
const chatHistory = [];  
const userData = { message: "", file: {} };  
  
// ✅ Always dark theme  
document.body.classList.remove("light-theme");  
localStorage.setItem("themeColor", "dark_mode");  
  
// ✅ Branding Info  
const CREATOR_INFO = {  
  name: "Samartha GS",  
  website: "https://samarthags.in",  
  botName: "Samartha AI",  
  description: "AI Assistant created by Samartha GS - A passionate web developer and AI enthusiast",  
  greeting: "Hello! I'm Samartha AI, created by Samartha GS – a skilled web developer and AI enthusiast who specializes in creating innovative web applications and AI-powered solutions. You can learn more about my creator and his amazing projects at samarthags.in. How can I assist you today?"  
};  
  
// ✅ Custom branded replies for specific questions  
const getBrandedResponse = (message) => {  
  const lower = message.toLowerCase();  
  
  if (lower.includes("are you chatgpt") || lower.includes("are you chat gpt")) {  
    return "No, I am not ChatGPT. I am a simple model called SGS, developed by Samartha GS.";  
  }  
  
  if (lower.includes("who are you")) {  
    return "I am an AI created by Samartha GS.";  
  }  
  
  if (lower.includes("who is samartha")) {  
    return "I'm able to reply because of him — Samartha GS is my creator.";  
  }  
  
  const triggers = [  
    "who developed you", "your creator", "your developer", "your owner",  
    "what is your name", "who built you", "about you",  
    "developer", "created you", "samartha gs", "about samartha ai"  
  ];  
  
  return triggers.some(t => lower.includes(t)) ? CREATOR_INFO.greeting : null;  
};  
  
// Create chat message div  
const createMessageElement = (content, ...classes) => {  
  const div = document.createElement("div");  
  div.classList.add("message", ...classes);  
  div.innerHTML = content;  
  return div;  
};  
  
// Scroll to bottom  
const scrollToBottom = () => container.scrollTo({ top: container.scrollHeight, behavior: "smooth" });  
  
// Typing effect  
const typingEffect = (text, textElement, botMsgDiv) => {  
  textElement.textContent = "";  
  const words = text.split(" ");  
  let wordIndex = 0;  
  
  typingInterval = setInterval(() => {  
    if (wordIndex < words.length) {  
      textElement.textContent += (wordIndex === 0 ? "" : " ") + words[wordIndex++];  
      scrollToBottom();  
    } else {  
      clearInterval(typingInterval);  
      botMsgDiv.classList.remove("loading");  
      document.body.classList.remove("bot-responding");  
    }  
  }, 40);  
};  
  
// API call  
const generateResponse = async (botMsgDiv) => {  
  const textElement = botMsgDiv.querySelector(".message-text");  
  controller = new AbortController();  
  
  chatHistory.push({  
    role: "user",  
    parts: [{ text: userData.message }, ...(userData.file.data ? [{ inline_data: (({ fileName, isImage, ...rest }) => rest)(userData.file) }] : [])],  
  });  
  
  try {  
    const response = await fetch(API_URL, {  
      method: "POST",  
      headers: { "Content-Type": "application/json" },  
      body: JSON.stringify({ contents: chatHistory }),  
      signal: controller.signal,  
    });  
  
    const data = await response.json();  
    if (!response.ok) throw new Error(data.error.message);  
  
    let responseText = data.candidates[0].content.parts[0].text.replace(/\*\*([^*]+)\*\*/g, "$1").trim();  
  
    // ✅ Check if branded response should override  
    const branded = getBrandedResponse(userData.message);  
    if (branded) responseText = branded;  
  
    typingEffect(responseText, textElement, botMsgDiv);  
    chatHistory.push({ role: "model", parts: [{ text: responseText }] });  
  
  } catch (error) {  
    textElement.textContent = error.name === "AbortError" ? "Response generation stopped." : error.message;  
    textElement.style.color = "#d62939";  
    botMsgDiv.classList.remove("loading");  
    document.body.classList.remove("bot-responding");  
    scrollToBottom();  
  } finally {  
    userData.file = {};  
  }  
};  
  
// Handle form submit  
const handleFormSubmit = (e) => {  
  e.preventDefault();  
  const userMessage = promptInput.value.trim();  
  if (!userMessage || document.body.classList.contains("bot-responding")) return;  
  
  userData.message = userMessage;  
  promptInput.value = "";  
  document.body.classList.add("chats-active", "bot-responding");  
  fileUploadWrapper.classList.remove("file-attached", "img-attached", "active");  
  
  const userMsgHTML = `  
    <p class="message-text"></p>  
    ${userData.file.data ? (userData.file.isImage ? `<img src="data:${userData.file.mime_type};base64,${userData.file.data}" class="img-attachment" />` : `<p class="file-attachment"><span class="material-symbols-rounded">image</span>${userData.file.fileName}</p>`) : ""}  
  `;  
  const userMsgDiv = createMessageElement(userMsgHTML, "user-message");  
  userMsgDiv.querySelector(".message-text").textContent = userData.message;  
  chatsContainer.appendChild(userMsgDiv);  
  scrollToBottom();  
  
  setTimeout(() => {  
    const botMsgHTML = `<img class="" src="" /> <p class="message-text">Sam is Thinking...</p>`;  
    const botMsgDiv = createMessageElement(botMsgHTML, "bot-message", "loading");  
    chatsContainer.appendChild(botMsgDiv);  
    scrollToBottom();  
    generateResponse(botMsgDiv);  
  }, 600);  
};  
  
// File upload  
fileInput.addEventListener("change", () => {  
  const file = fileInput.files[0];  
  if (!file) return;  
  
  const isImage = file.type.startsWith("image/");  
  const reader = new FileReader();  
  reader.readAsDataURL(file);  
  
  reader.onload = (e) => {  
    fileInput.value = "";  
    const base64String = e.target.result.split(",")[1];  
    fileUploadWrapper.querySelector(".file-preview").src = e.target.result;  
    fileUploadWrapper.classList.add("active", isImage ? "img-attached" : "file-attached");  
  
    userData.file = { fileName: file.name, data: base64String, mime_type: file.type, isImage };  
  };  
});  
  
// Cancel file upload  
document.querySelector("#cancel-file-btn").addEventListener("click", () => {  
  userData.file = {};  
  fileUploadWrapper.classList.remove("file-attached", "img-attached", "active");  
});  
  
// Stop response  
document.querySelector("#stop-response-btn").addEventListener("click", () => {  
  controller?.abort();  
  userData.file = {};  
  clearInterval(typingInterval);  
  chatsContainer.querySelector(".bot-message.loading")?.classList.remove("loading");  
  document.body.classList.remove("bot-responding");  
});  
  
// Handle suggestions (if any exist)  
document.querySelectorAll(".suggestions-item").forEach((suggestion) => {  
  suggestion.addEventListener("click", () => {  
    promptInput.value = suggestion.querySelector(".text").textContent;  
    promptForm.dispatchEvent(new Event("submit"));  
  });  
});  
  
// Hide controls on focus (for mobile)  
document.addEventListener("click", ({ target }) => {  
  const wrapper = document.querySelector(".prompt-wrapper");  
  const shouldHide = target.classList.contains("prompt-input") || (wrapper.classList.contains("hide-controls") && (target.id === "add-file-btn" || target.id === "stop-response-btn"));  
  wrapper.classList.toggle("hide-controls", shouldHide);  
});  
  
// Form submit & file click  
promptForm.addEventListener("submit", handleFormSubmit);  
promptForm.querySelector("#add-file-btn").addEventListener("click", () => fileInput.click()); 